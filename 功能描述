1、现在有一种通信协议，需要以差分曼彻斯特码来传输
2、差分Manchester码如下所述：

    假如有一段数据，是"10101100"，"10"或者"01"代表一个短1和一个短0，"11"代表一个长1，通常是短1的两倍长度，同理"00"代表一个长0，通常是短0的两倍长度。
    我们的系统，从总线接收信号，通过模拟电路的TDC模块，计量出每个边沿间的间隔。
    以"10101100"为例，TDC模块计量出每个边沿间的间隔，分别为：10，9，11，8，20，19，分别代表第一个“1”的电平长度为10个TDC单位，第二个“0”的电平长度为9个TDC单位，
    20则代表“11”这个长1的电平长度为20个TDC单位，19则代表“00”这个长0的电平长度为19个TDC单位。同时，我们会通过某种方式获得“尺子”，尺子有两类，一个叫“十分尺”，一个叫“十五分尺”。
    除此之外，我们还需要知道一些额外的知识，那就是时钟沿和数据眼，在差分曼彻斯特编码中，信号最开始是0，也就是低电平，然后第一个时钟沿到来，此时信号为高电平，也就是“10101100”中的第一个1，
    那么这个从0到“1”的过程的边沿，就是时钟沿，以此类推，“10”中的下降沿就是数据沿，以此类推，“11”中的上升沿就是数据沿，但是两个1之间隐藏了一个数据沿，同时，从“11”到“00”中的下降沿是时钟沿
    “00”内部隐藏了数据沿

    TDC不仅会测量总线信号每个电平的持续时间，还会通过边沿产生一个时钟，将数据push进异步fifo，我们在解码时，为了不导致underflow，会在fifo内部存在超过4个数据的时候，开始pop数据，也就是说，
    fifo会有一个数据信号，叫“async_pop_size”，这个信号指明了pop端看到的fifo内部的数据个数。且fifo端的pop数据没有reg。
    解码模块会输入一个时钟，叫“clk_in”，还有一个“clk_or_data”，当clk_or_data为1时，表示当前pop出的数据，代表的是从时钟沿到数据沿的长度，当clk_or_data为0时，表示当前pop出的数据，代表的是从数据沿到时钟沿的长度。
    解码的过程为，当pop_size大于等于4，并且clk_or_data为1时，即此时pop口子上的数据为从时钟沿到数据沿的长度，可以拉高pop_valid，也就是开始pop数据。
    使用十五分尺对第一个“1”所对应的10进行解码，发现十五分尺大于10，那么就表明这是个短“1”，而如果
